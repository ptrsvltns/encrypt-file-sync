const fs = require("fs-extra");const path = require("path");const chalk = require('chalk');const uuid = require('uuid').v4;const md5File = require('md5-file');const crypto = require('crypto');const question = require("./src/question");const zip = require("./src/zip");function loadJson(filename) {  try {    return fs.readJsonSync(filename);  } catch {    return null;  }}var argv = require('minimist')(process.argv.slice(2));(async () => {  let config;  if (!argv.from && !argv.to) {    const configFile = path.resolve(__dirname, "config", (await question.config()).config);    config = loadJson(configFile);  } else {    config = argv;  }  if (!config) {    console.error(chalk.red("配置文件不存在"));    return;  }  if (!config.from || !config.to) {    console.error(chalk.red("配置文件格式不对") + "\r\n" + "格式: " + chalk.blue("{ from, to }"));    return;  }  if (!fs.existsSync(config.from)) fs.mkdirsSync(config.from);  if (!fs.existsSync(config.to)) fs.mkdirsSync(config.to);  console.log("文件源", path.resolve(config.from));  console.log("同步", path.resolve(config.to));  const fullname = function (filename) {    if (!filename) return "";    let res = filename.replace(path.resolve(config.to) + "\\", "")      .replace(path.resolve(config.to), "")      .replace(path.resolve(config.from) + "\\", "")      .replace(path.resolve(config.from), "");    return res;  }  let cachePath = config.cache ? path.resolve(config.cache) : path.resolve(config.to, "cache");  const hexMode = config.hex !== false;  const fullHexMode = config.fullhex === true || config.fullhex === 'true';  const dbMode = config.db !== false && config.db !== 'false';  const md5Mode = config.md5 === true && config.md5 === 'true';  const ignore = [    "$RECYCLE.BIN",    "System Volume Information",    /\._____$/g  ];  if (config.ignore) {    let i = config.ignore;    if (typeof (i) == "string") {      ignore.push(new RegExp(i));    } else if (Array.isArray(i) && i.length) {      for (let x = 0; x < i.length; x++) {        ignore.push(new RegExp(i[x]));      }    }  }  const algorithm = 'aes-256-ctr';  const key = config.key || "c48550a506734b21";  let iv = config.iv || "f5a871d66f804ca3";  iv = Buffer.from(iv, "utf8");  const encryptFile = function (filename, dist) {    const encryptKey = crypto.createHash("sha256").update(key).digest("base64");    let cipher = crypto.createCipheriv(algorithm, Buffer.from(encryptKey, 'base64'), iv);    const buffer = fs.readFileSync(filename);    let encrypted = cipher.update(buffer);    encrypted = Buffer.concat([encrypted, cipher.final()]);    fs.writeFileSync(dist, encrypted);  }  const decryptFile = function (filename, dist) {    const decryptKey = crypto.createHash("sha256").update(key).digest("base64");    let decipher = crypto.createDecipheriv(algorithm, Buffer.from(decryptKey, 'base64'), iv);    const buffer = fs.readFileSync(filename);    let decrypted = decipher.update(buffer);    decrypted = Buffer.concat([decrypted, decipher.final()]);    fs.writeFileSync(dist, decrypted);  }  const encrypt = function (str) {    const encryptKey = crypto.createHash("sha256").update(key).digest("base64");    let cipher = crypto.createCipheriv(algorithm, Buffer.from(encryptKey, 'base64'), iv);    const buffer = Buffer.from(str);    let encrypted = cipher.update(buffer);    encrypted = Buffer.concat([encrypted, cipher.final()]);    return encrypted.toString('hex');  }  const decrypt = function (str) {    const decryptKey = crypto.createHash("sha256").update(key).digest("base64");    let decipher = crypto.createDecipheriv(algorithm, Buffer.from(decryptKey, 'base64'), iv);    const buffer = Buffer.from(str, 'hex');    let decrypted = decipher.update(buffer);    decrypted = Buffer.concat([decrypted, decipher.final()]);    return decrypted.toString();  }  const readdirSync = function (dir, result, ext = true) {    result = result || []    let files = fs.readdirSync(dir)    for (let i = 0; i < files.length; i++) {      let file = files[i];      let temp = path.resolve(dir, file);      if (temp == cachePath) continue;      let skip = false;      for (let x of ignore) {        skip = file == x || x.test && x.test(file);        if (skip) break;      }      if (skip) continue;      if (fs.statSync(temp).isDirectory()) {        result = readdirSync(temp, result, ext)      } else {        var info = {          fullname: temp,          dir: dir,          dirname: fullname(dir),          filename: file.replace(path.extname(file), ""),          basename: file        };        try {          info.extname = path.extname(/^[0-9a-fA-F]+$/.test(file) ? decrypt(file) : file);        } catch {          info.extname = path.extname(file);        }        try {          if (/^[0-9a-fA-F]+$/.test(file)) {            info.decrypt = decrypt(file);            if (fullHexMode) {              info.absolute = fullname(info.decrypt);              info.dirname = path.join(fullname(info.decrypt), "..");              info.decrypt = fullname(path.basename(info.decrypt));            } else {              info.absolute = fullname(path.resolve(dir, info.decrypt));            }            if (!ext) info.absolute = info.absolute.replace(path.extname(info.decrypt), "");          }        } catch { }        try {          if (!info.absolute) {            info.absolute = fullname(temp);          }        } catch { }        result.push(info);      }    }    return result  }  const getItem = function (array, key, data) {    for (let i of array) {      if (i[key] === data) return i;    }    return null;  }  if (dbMode) {    let encriptMode = true;    let db = null;    try {      let dbFile = path.resolve(config.to, "db._____");      if (fs.existsSync(dbFile)) db = JSON.parse(decrypt(fs.readFileSync(dbFile).toString()));      if (!db) {        dbFile = path.resolve(config.from, "db._____");        if (fs.existsSync(dbFile)) {          db = JSON.parse(decrypt(fs.readFileSync(dbFile).toString()));          encriptMode = false;        }      }    } catch (e) {      console.error(e);      process.exit();    }    if (!db) db = {};    if (!db.files) db.files = [];    if (encriptMode) {      cachePath = config.cache ? path.resolve(config.cache) : path.resolve(config.from, "cache");      if (!fs.existsSync(cachePath)) fs.mkdirsSync(cachePath);      const from = readdirSync(path.resolve(config.from)).sort((a, b) => a.absolute.localeCompare(b.absolute));      const to = db.files.sort((a, b) => a.absolute.localeCompare(b.absolute));      (() => {        const temp = readdirSync(path.resolve(config.to)).sort((a, b) => a.absolute.localeCompare(b.absolute));        for (let i = 0; i < temp.length; i++) {          const filename = temp[i].filename;          if (!getItem(to, "id", filename)) {            console.log("删除数据库不存在的文件", temp[i].fullname);            fs.rmSync(temp[i].fullname, { force: true });          }        }      })();      const to2 = readdirSync(path.resolve(config.to)).sort((a, b) => a.absolute.localeCompare(b.absolute));      try {        for (let i = to.length - 1; i >= 0; i--) {          if (!getItem(from, "absolute", to[i].absolute)) {            const temp = path.resolve(config.to, to[i].id);            console.log("删除", temp);            fs.unlinkSync(temp);            to.splice(i, 1);          }        }        for (let i = 0; i < from.length; i++) {          const filenameFrom = from[i].absolute;          const md5From = md5Mode ? md5File.sync(from[i].fullname) : null;          const fromStat = fs.statSync(from[i].fullname);          const fileTo = getItem(to, "absolute", filenameFrom);          const fileTo2 = fileTo?.id ? getItem(to2, "filename", fileTo.id) : null;          if (!fileTo || !fileTo2 || fromStat.size != fileTo.size || fromStat.mtime.getTime() != fileTo.mtime || (md5Mode && md5From != fileTo.md5)) {            let cache = path.resolve(cachePath, filenameFrom + ".cache");            let obf = path.resolve(cachePath, filenameFrom + ".obf");            await zip.archive(from[i].fullname, cache);            if (!fs.existsSync(path.dirname(obf))) fs.mkdirsSync(path.dirname(obf));            encryptFile(cache, obf);            fs.unlinkSync(cache);            let id = fileTo?.id || uuid();            let temp = path.resolve(config.to, id);            if (fileTo?.id) {              fs.rmSync(temp, { force: true });            } else {              while (true) {                if (!fs.existsSync(temp)) break;                id = uuid();                temp = path.resolve(config.to, id);              }            }            if (!fs.existsSync(path.dirname(temp))) fs.mkdirsSync(path.dirname(temp));            console.log(!fileTo ? "同步" : "变化", from[i].fullname);            if (fileTo) {              if (fromStat.size != fileTo.size) console.log("尺寸", fromStat.size, fileTo.size);              if (fromStat.mtime != fileTo.mtime) console.log("修改时间", fromStat.mtime, fromStat.mtime.getTime(), fileTo.mtime);              if (md5Mode && md5From != fileTo.md5) console.log("MD5", md5From, fileTo.md5);            }            console.log("生成", temp);            fs.copyFileSync(obf, temp);            fs.utimesSync(temp, fromStat.atime, fromStat.mtime);            fs.unlinkSync(obf);            if (!fileTo?.id) {              to.splice(i, 0, {                dirname: from[i].dirname,                filename: from[i].filename,                basename: from[i].basename,                extname: from[i].extname,                absolute: from[i].absolute,                md5: md5From,                size: fromStat.size,                atime: fromStat.atime.getTime(),                mtime: fromStat.mtime.getTime(),                ctime: fromStat.ctime.getTime(),                id: id              });            } else {              fileTo.md5 = md5From;              fileTo.size = fromStat.size;              fileTo.atime = fromStat.atime.getTime();              fileTo.mtime = fromStat.mtime.getTime();              fileTo.ctime = fromStat.ctime.getTime();            }          }        }      } catch (e) {        console.error(e);      }      db.files = to;      fs.writeFileSync(path.resolve(config.to, "db._____"), encrypt(JSON.stringify(db)));    }    else {      if (!fs.existsSync(cachePath)) fs.mkdirsSync(cachePath);      const from = db.files.sort((a, b) => a.absolute.localeCompare(b.absolute));      const to = readdirSync(path.resolve(config.to)).sort((a, b) => a.absolute.localeCompare(b.absolute));      try {        for (let i = to.length - 1; i >= 0; i--) {          if (!getItem(from, "absolute", to[i].absolute)) {            console.log("删除", to[i].fullname);            fs.unlinkSync(to[i].fullname);            to.splice(i, 1);          }        }        for (let i = 0; i < from.length; i++) {          const filenameFrom = from[i].absolute;          const fileTo = getItem(to, "absolute", filenameFrom);          const md5To = fileTo && md5Mode ? md5File.sync(fileTo.fullname) : null;          const toStat = fileTo ? fs.statSync(fileTo.fullname) : null;          if (!fileTo || toStat.size != from[i].size || toStat.mtime.getTime() != from[i].mtime || (md5Mode && md5To != from[i].md5)) {            let obf = path.resolve(cachePath, filenameFrom + ".obf");            if (!fs.existsSync(path.dirname(obf))) fs.mkdirsSync(path.dirname(obf));            const fileFrom = path.resolve(config.from, from[i].id);            decryptFile(fileFrom, obf);            let temp = path.resolve(config.to, from[i].dirname, from[i].basename);            if (!fs.existsSync(path.dirname(temp))) fs.mkdirsSync(path.dirname(temp));            let cache = temp + ".cache";            console.log(!fileTo ? "同步" : "变化", fileFrom);            if (fileTo) {              if (toStat.size != from[i].size) console.log("尺寸", toStat.size, from[i].size);              if (toStat.mtime != from[i].mtime) console.log("修改时间", toStat.mtime, toStat.mtime.getTime(), from[i].mtime);              if (md5Mode && md5To != from[i].md5) console.log("MD5", md5To, from[i].md5);            }            console.log("生成", temp);            fs.copyFileSync(obf, cache);            await zip.extract(cache, path.dirname(temp));            fs.utimesSync(temp, new Date(from[i].atime), new Date(from[i].mtime));            fs.unlinkSync(cache);            fs.unlinkSync(obf);            to.splice(i, 0, {              dirname: from[i].dirname,              filename: from[i].filename,              basename: from[i].basename,              extname: from[i].extname,              absolute: from[i].absolute            });          }        }      } catch (e) {        console.error(e);      }    }  } else {    if (!fs.existsSync(cachePath)) fs.mkdirsSync(cachePath);    const from = readdirSync(path.resolve(config.from)).sort((a, b) => a.absolute.localeCompare(b.absolute));    const to = readdirSync(path.resolve(config.to), null, false).sort((a, b) => a.absolute.localeCompare(b.absolute));    try {      for (let i = 0; i < from.length; i++) {        const encriptMode = !from[i].extname.includes("zept");        const filenameFrom = !encriptMode ? from[i].absolute.replace(from[i].extname, "") : from[i].absolute;        const fromStat = fs.statSync(from[i].fullname);        const toFile = getItem(to, "absolute", filenameFrom);        const toStat = toFile ? fs.statSync(toFile.fullname) : null;        if (!toFile || fromStat.mtime.getTime() != toStat.mtime.getTime()) {          let cache = path.resolve(cachePath, filenameFrom + ".cache");          let obf = path.resolve(cachePath, filenameFrom + ".obf");          if (encriptMode) {            await zip.archive(from[i].fullname, cache);          } else {            cache = from[i].fullname;          }          if (!fs.existsSync(path.dirname(obf))) fs.mkdirsSync(path.dirname(obf));          if (encriptMode) {            encryptFile(cache, obf);            fs.unlinkSync(cache);          } else {            decryptFile(cache, obf);          }          let temp = "";          if (encriptMode) {            if (hexMode) {              if (fullHexMode) {                temp = path.resolve(config.to, encrypt(path.join(from[i].dirname, from[i].basename + ".zept")));              } else {                temp = path.resolve(config.to, from[i].dirname, encrypt(from[i].basename + ".zept"));              }            } else {              temp = path.resolve(config.to, from[i].dirname, from[i].basename + ".zept");            }          } else {            temp = path.resolve(config.to, from[i].dirname, (from[i].decrypt || from[i].basename) + ".zip");          }          if (!fs.existsSync(path.dirname(temp))) fs.mkdirsSync(path.dirname(temp));          fs.copyFileSync(obf, temp);          if (!encriptMode) {            await zip.extract(temp, path.dirname(temp));            console.log("生成", path.resolve(config.to, filenameFrom));            fs.utimesSync(path.resolve(config.to, filenameFrom), fromStat.atime, fromStat.mtime);            fs.unlinkSync(temp);          } else {            console.log("同步", from[i].fullname);            console.log("生成", temp);            fs.utimesSync(temp, fromStat.atime, fromStat.mtime);          }          fs.unlinkSync(obf);          to.splice(i, 0, {            dirname: from[i].dirname,            filename: from[i].filename,            basename: from[i].basename,            extname: from[i].extname,            absolute: from[i].absolute          });        }      }    } catch (e) {      console.error(e);    }  }  console.log("删除", cachePath);  fs.rmSync(cachePath, { recursive: true, force: true });})();